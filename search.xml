<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Akka-Actor-RPC]]></title>
    <url>%2F2018%2F09%2F29%2FAkka-RPC%2F</url>
    <content type="text"><![CDATA[整理业务逻辑分析思路Akka实现简单通讯功能情景模拟：学生和老师远程交流。并行处理双方的收发信息。 demo for RPC赵老师编程思路： 程序执行入口 包名:com._51doit.akka.Master主服务器(scala: object or class?)要有程序执行入口，且需要创建该类的实例 从服务器 Worker 主从服务都需要单独启动，各自都要有专属的main方法 逻辑 先启动Master再启动Worker，worker给master建立连接发送消息，master返回消息给worker 给类添加相应的功能(类方法) worker发送消息的功能(自己写网络和IO过于繁琐，选择利用框架，集成或实现接口) Master接收消息的功能通过集成重写Actor类中的Receive方法来实现 ctrl+i实现未被实现的方法 (重写抽象方法，可以去掉override) 如何启动服务 管理Actor的角色是ActorSystem(单例：一个JVM中只有一个即可 创建并管理Actor) 不要强行记忆代码(开发环境辅助编程) 两种管理系统：MasterActorSystem WorkerActorSystem 写代码不是从上至下编写的（灵活） RPC自娱自乐模式 12345678910111213141516171819202122232425262728293031323334353637383940import akka.actor.&#123;Actor, ActorSystem, Props&#125;import com.typesafe.config.ConfigFactoryclass Master extends Actor&#123; //Actor中主要用来接收消息的方法 // Receive[scala.any, scala.Unit]： //偏函数：做模式匹配 接收任何类型的消息，无返回,不响应Master //阻塞队列BlockingQueue(java.util.concurrent) Lock.class override def receive: Receive = &#123; case "hello" =&gt; &#123; println("receive a message") &#125; &#125;&#125;object Master&#123; def main(args: Array[String]): Unit = &#123; //akka中Actor启动必须要绑定的配置信息，如：地址、端口号 //接收main方法传入的字符串 val host = args(0) val port = args(1).toInt //多个属性名和值的情况下如何处理到一个字符串里 //如何取到属性值 //指定akka通信的核心类 val confStr = s""" |akka.actor.provider = "akka.remote.RemoteActorRefProvider" |akka.remote.netty.tcp.hostname = $host |akka.remote.netty.tcp.port = $port """.stripMargin //parse:解析配置文件 val config: Config = ConfigFactory.parseString(confStr) //apply(name: String,config Config) //ActorSystem相当于创建actor实例的工厂 actorOf() val masterActorSystem = ActorSystem("MasterActorSystem", config) //masterACtor理解为具有接收发送消息功能的master实例对象 功能可执行的行动者 //Props[Master]:通过反射(传入要创建对象的类型)来创建Master的实例 val masterActor = masterActorSystem.actorOf(Props[Master], name = "Master") masterActor ! "hello" //向masterActor发送一个异步消息(发出后不用等待) &#125;&#125; 12345678910111213141516171819202122232425262728import akka.actor.Actorclass Worker extends Actor &#123; //Actor中主要用来接收消息的方法 override def receive: Receive = &#123; case "hello" =&gt; &#123; println("hello,Worker") &#125; &#125;&#125;object Worker &#123; def main(args: Array[String]): Unit = &#123; val host = args(0) val port = args(1).toInt val confStr = s""" |akka.actor.provider = "akka.remote.RemoteActorRefProvider" |akka.remote.netty.tcp.hostname = $host |akka.remote.netty.tcp.port = $port """.stripMargin val conf: Conf = ConfigFactory.parseString(confStr) val workerActorSystem = ActorSystem("WorkerActor", conf) val workerActor = workerActorSystem.actorOf(Props[Worker], name = "Worker") workerActor ! "hello" &#125;&#125;]]></content>
      <tags>
        <tag>思路整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The method of map in Java instead of Scala]]></title>
    <url>%2F2018%2F09%2F27%2FThe-method-of-map-in-Java-instead-of-scala%2F</url>
    <content type="text"><![CDATA[用Java实现Scala中map方法具体需求：操作一个字符串集合中的元素，加入一段字符串或者是将小写字母改成大写字母。… 需求的引出理清scala中map方法实现的过程，函数编程思想与java面向对象编程思想的对比。通过Java模仿函数式编程，充分把握到scala的优势。 思考过程熟悉scala中map方法的使用1234scala&gt; val arr = Array("Spark", "Hadoop", "Scala", "Hbase", "Flink")arr: Array[String] = Array(Spark, Hadoop, Scala, Hbase, Flink)scala&gt; arr.map(x =&gt; x.toUpperCase + "2.0")res1: Array[String] = Array(SPARK2.0, HADOOP2.0, SCALA2.0, HBASE2.0, FLINK2.0) scala中的集合调用map方法，循环操作集合中的元素。map方法是在进行”做映射”的操作。所谓”映射”，即是指两个集合中的元素有了一一对应的关系。数学知识牵引：函数y=f(x)就存在着一种映射关系，一个x的值就会有一个y值与之对应。我将x =&gt; f(x)用数学中函数的思想来理解的话，结合当前情景，数组调用了map方法，map方法制造了一种映射关系：依次传入集合中的元素(相当于x)到函数式x.toUpperCase + &quot;2.0&quot;中进行”_运算_”,结果放进了新的数组里。arr2 = f(arr1)，两个集合中的对应元素见存在的映射关系。 用scala实现wordcount的功能更容易统计单词出现的次数1234scala&gt; val arr = Array("i believe i can fly", "i can fly high", "just fly as you can", "believe youself")arr: Array[String] = Array(i believe i can fly, i can fly high, just fly as you can, believe youself)scala&gt; arr.flatMap(_.split(" ")).groupBy(x =&gt; x).mapValues(_.length).toList.sortBy(-_._2)res2: List[(String, Int)] = List((i,3), (can,3), (fly,3), (believe,2), (just,1), (as,1), (you,1), (high,1), (youself,1)) Java实现map(x =&gt; x.toUpperCase + “2.0”)map中传入我们想要实现的逻辑语句，对外不要求理会底层代码是如何实现的。Java中面向对象的思想：明确操作对象，细化逻辑实现过程(面向过程)，面向对象是对过程进行了封装，便于编程人员着重于业务逻辑编程上。 明确需求–&gt;设计接口–&gt;实现抽象方法–&gt;实例化对象–&gt;调用方法–&gt;实现需求 对象是集合：封装一个集合类MyList,将传入的逻辑函数设计为一个接口MapFunction123456789101112131415161718192021package com.masato;import java.util.ArrayList;import java.util.List;public class MyList &#123; //操作一个集合中的元素，产生了新的集合 private List&lt;String&gt; oldList; public MyList(List&lt;String&gt; list) &#123; this.oldList = list; &#125; //定义类似于scala中的map方法：map(传入逻辑)--&gt;实现需求 public List&lt;String&gt; map(MapFunction func) &#123; //生成新的集合，用于存放旧集合操作后的元素 List&lt;String&gt; newList = new ArrayList&lt;&gt;(); for(String word : oldList) &#123; //传入的逻辑参数调用自定义接口中的抽象方法(具体实现需要关联传入参数有关) String newWord = func.transform(word); newList.add(newWord); &#125; return newList; &#125;&#125; ####1234package com.masato;public interface MapFunction &#123; public String transform(String word);&#125; ####123456789101112131415161718192021222324252627282930313233343536package com.masato;import java.util.Arrays;import java.util.List;public class TestMyList &#123; public static void main(String[] args) &#123; String[] words = &#123;"Spark", "Hadoop", "Flink", "Hbase"&#125;; List&lt;String&gt; wordlist = Arrays.asList(words); MyList myList = new MyList(wordlist); //1、匿名实现类 /* List&lt;String&gt; nList = myList.map(new MapFunction() &#123; @Override public Stringtransform(String word) &#123; return word.toUpperCase() + "2.0"; &#125; &#125;); */ //2、创建传入map中的逻辑函数的对象，实现方法 MapFunction myFunc = new MapFunction() &#123; @Override public String transform(String word) &#123; return word.toUpperCase() + "2.0"; &#125; &#125;; List&lt;String&gt; nList = myList.map(myFunc); //3、使用Lambdas表达式(1.8以后) //List&lt;String&gt; nList = myList.map(word -&gt; word.toUpperCase() + "2.0"); //遍历新集合中的元素，依次打印到控制台 for (String s : nList) &#123; System.out.println(s); &#125; &#125;&#125; #### To be continue…]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>scala</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Start a new Life]]></title>
    <url>%2F2018%2F09%2F26%2FStart-a-new-Life%2F</url>
    <content type="text"><![CDATA[Start to write the first article on my blog.Learn to blog by hello-world. get knowledge of Markdown language. write down something I have experienced in life. just insist on learning unless you really give up growing to be a awesome person. 12]]></content>
      <categories>
        <category>testCategories</category>
      </categories>
      <tags>
        <tag>-testTag1 -testTag2</tag>
      </tags>
  </entry>
</search>
